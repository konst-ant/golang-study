### Synopsis on Golang
#---------------------------------------------------------

## Basics, Control Flow, Functions
- Package - containers to logically decompose code
    - mandatory package is `main`, with function `main()`
    - standard packages
        Go has extensive library of standard packages, coming within distribution
    - import package
        use import - to import functions from package
    - external packages (from github, etc.)
    Note: packages can span many files, e.g. "main package" can be declared in two different files within project. So you will not need to import around same package files

    Note: How to decompose code into packages? These are recommended strategies:
        - by usage
        - dy application domain
        - by business task

- Module - correspond to application and executable to be built
    - module underneath uses a set of packages
    - initialize module with `go mod init`


- Basic CLI commands
    - `go mod init <module_name>`
        convention for module name is like: github.com/path/../path/module
        if you want to publish module can use only path/../path/module
        as a result we get go.mod file in the project. note we can rename module directly in go.mod
    - `go build`
        builds project, with outcome build of executable
        resulting executable is native (for any OS platform), is self-contained and not requiring Go installed
        resulting executable will have name of the module, e.g. for module path/../path/module - named 'module'
    - `go run <file.go>`
        execute without building executable, will require Go installed
        Note: in more general case e.g. when package spans several files, we need to do `go run .` from project root rather than by file name

- Variable & Constant & Types
    - `var myVar = 5.2`
        declare and initialize 'myVar' variable
            Note: with this declaration myVar type is inferred => float64


    - `var myVar float64 = 5.2`
        explicitly define variable type
            Note: we can declare variable without initialization only this way, e.g. `var myVar float64`

    - `myVar := 5.2`
        type is always inferred with this way, we can not use explicit type declaration

    - `const myConst = 2`
        use 'const' similarly with 'var' to declare and init constants
        Note: if type not declared, `myConst` gets type `untyped` and flexible to auto convert to compatible types (like in Java)

    - Note: all variables/constants must be used, otherwise code will not run. Same apply for functions, and more.

    - Note: Golang is strictly typed language - it can not automatically transfer between compatible types as in Java
        we need to explicitly cast type using standard functions e.g. `float(myVarInt)` casts int to float64

    - Golang types:
        - Basic types
            - int, int8, int16, int32, int64
            - float32, float64
            - uint, uint8, uint16, uint32, uint64, uintptr (keep pointer)
            - string
        - Aggregate types
            - array
            - struct
        - Reference types
            - slice
            - map
            - function
            - channel
            Note: reference type variables are passed by pointer (reference), hence can be changed directly in receiving function
        - Interface types
            -
        - Pointers
            `num := 10
             numPointer := &num` - declaring pointer, which will be pointing to a variable num and thus be reference type
             Note: use pointer to avoid copying if required, or if you want to mutate the variable

             `var p &int` - declaring pointer variable

             `func(num *int)` -declaring function, which receives a pointer
             Note: for pointer variables you will see them like this *int (as in C), basically keeping the memory address. And we dereference pointer with (*numPointer) as well

             `*num = *num * 2` - if num is a pointer, this is how we can set new value to the variable (say, inside function receiving a pointer)
             Note: for array pointer operating with dereferenced pointer would look like this `(*arr)[index]`, however it's exempted to use just arr[index]
             Note: dereferencing pointer to nil will make runtime error

        - Rune
            - Rune is not an independent data type, but syntactic sugar (equivalent int32) for reading out string Unicode symbols into letters (runes)

            - `for _, ch := range str {
                        fmt.Print(ch, string(ch))
               }` - will split str into Runes, and print out Unicode code and representation of each symbol in string

            - alternatively declare `[]rune(str)` - same build slice of runes from string, but with syntactic sugar

            - To convert back slice of runes into string do `string(rune)`

    - Type alias:
        `type stringMap = map[string]string` - declares 'stringMap' type that is an alias of map[string]string
        bookmarks stringMap - declare variable using type alias, type alias can be used in all places where type can be used


- Error
    - use `error` type to return error
    - use `errors.New("ERROR_NAME")`
    - use `panic("Message string")` to exit with unrecoverable error
        Note: panic() will return 2 app status code. If you want to control the return status code, use os.Exit(status_code)

- Array & Slice
    - `var myArr = [5]int`
        declare array of int, size 5 (will be initialized with default int value 0)

    - `myArr := [5]int{1, 2, 3}`
        declare and initialize array of int size 5
            Note: we could initialize array partially, the rest elements will get default values as above

    - `myArr := [5]int{}`
            create empty array of int size 5

    - `var myInt = myArr[1]`
    - `myArr[1] = 8`
        get/set element of an array

    - `mySlice := myArr[1:3]`
        create slice of myArr from index 1 (inclusive) to index 3 (excluded)
            Note: left / right boundary of slice expression can be omitted

    - `myDynamicSlice := []int{1, 2, 3}`
        create a slice of size 3 and capacity 3

    - We can create slice over slice, with any nesting, and they all have same behaviour

    - `len(mySlice)`
    - `cap(mySlice)`
        get length and capacity of mySlice
            Note:
            len() will return length of the "window" the slice represents
            cap() will return size of available slots (up to the end of array) upon which the slice is standing. So a slice is extendable beyond it's right boundary up to the end of array

    - `extendedSlice := append(myDynamicSlice, 100)``
        add 100 to the tail of slice (extending it)
        Note: be careful when using append() on slices, old slice variables will remain unchanged. Reassign old slice variables if you want them to get updated, e.g. `myDynamicSlice = append(myDynamicSlice, 100)`

    - Slice is not using new memory -n not copying from original array, but it is a "window" in original array. Changing slice will change the array
        - smth similar to Java:
            `Integer[] arr = new Integer[] {1, 2, 3};
            List list = Arrays.asList(arr);`

    - extendedSlice[1:] - will remove the 0-th element of the slice

    - `mergedSlices := append(myDynamicSlice1, myDynamicSlice2...)` - unpack elements of myDynamicSlice2 to return a sequence of elements

    - `for index, value := range mySlice {}` - iterate through the slice

- Map

    - m := map[string]string {"one" : "apple", "two": "windows"}
        declare and initialize map string -> string
    - m["one"]
        get value from map by key
    - m["one"] = "pineapple"
        change map value by key, or add value if the key is not in the map
    - delete(m, "one")
        delete element from map by key. if key doesn't exist there will be no error
    - for key, value := range m {
    }
        iterate through map
    - len(m)
        return length of the map.
        Note: map has no capacity
    - make(map[string]string, 3) - create map and allocate memory for 3 elements
        If we wouldn't use make, adding new elements to the map will allocate memory during adding
    - make([]int, 10) - create and allocate memory for slice (array underneath of ints)
    - Note: getting non-existent key from the map will return default value of the map's value type

- Struct

    - `type account struct {
            login string
            password string
            url string
       }` -  declare the struct type

    - account1 := account{
        "login",
        "password",
        "url",
    } - create account variable (comma inside field declaration is everywhere mandatory)
    Note: order of field declaration here is important
    Note: we can use variables in place of literals here

    - account2 := account{
            login: "login",
            password: "password",
            url: "url",
    } - create account variable with explicit binding
    Note: with this notation we can partially initialize struct variable, the omitted fields getting default values. We can have uninitialized (empty) struct variable as well_
    Note: we can print structures with fmt.Print(account2)

- Struct methods

    - `func (account) outputPassword(acc *account) {}` - declare method upon account structure
        Note: methods are declared outside of structs (this gives some flexibility? Huh?)
        Note: declare methods in same package and near with struct declaration

    - `func (acc account) outputPassword() {}` - alternatively we can declare method binding with "instance declaration", acc variable is now the bound account instance
        Note: for methods that need mutate object, we would need to do pointer declaration
        `func (acc *account) generationPassword() {}`
        Note: constructor method (function) is just a function, in which you create strict instance and return typically pointer (to avoid object copying)


- OOP
    - Go has now inheritance concept
    - Composition
        - `accountWithTimestamp {
                createdAt time,
                updatedAt time,
                account // embedded field
        }` - declare extended structure base on existing "account"

        - `extendedAcc := &accountWithTimestamp {
               createdAt: time.Now(),
               updatedAt: time.Now(),
               account: {
                    url: "url",
                    login: "login",
                    password: "password",
               }
        }` - create variable of composition structure
        Note: we can access embedded field by `extendedAcc.account.url` or equivalently by `extendedAcc.url`




- Questions
    - Will `append(myDynamicSlice, 100)` allocate new memory and copy array to new memory? If yes, isn't is suboptimal?
    - How can I do join / subtract / ... of arrays / slices in Go?
    - Assume we have a dynamic slice `myDynamicSlice := []int{1, 2, 3}`, how can we remove the 0-th element from it? And would the address of the slide be changed (requiring change of variables)?





- Misc
    - use ` ` to fmt.Print multi-line strings
    - func() can return many values e.g. `func() (float64, float64)` and `return val1, val2`
    - Go has only one cycle operator `for`. To do `while` or infinite loop use for `{ }`. Also use operators `break`, `continue`
    - we can use switch `{ case <condition>: .. case <condition> .. }` working as `if {} else if {} else`
    - 'null' in Go is `nil`
    - Labels
        label1: - declare label, which can be used as reference, e.g. break label1
    - import math.rand.v2 - for random generator
    - `time` - library to use time

## Data Structure